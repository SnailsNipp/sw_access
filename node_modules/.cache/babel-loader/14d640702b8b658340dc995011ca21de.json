{"ast":null,"code":"'use strict';\n\nconst {\n  signalsByName\n} = require('human-signals');\nconst getErrorPrefix = _ref => {\n  let {\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  } = _ref;\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n  if (isCanceled) {\n    return 'was canceled';\n  }\n  if (errorCode !== undefined) {\n    return `failed with ${errorCode}`;\n  }\n  if (signal !== undefined) {\n    return `was killed with ${signal} (${signalDescription})`;\n  }\n  if (exitCode !== undefined) {\n    return `failed with exit code ${exitCode}`;\n  }\n  return 'failed';\n};\nconst makeError = _ref2 => {\n  let {\n    stdout,\n    stderr,\n    all,\n    error,\n    signal,\n    exitCode,\n    command,\n    timedOut,\n    isCanceled,\n    killed,\n    parsed: {\n      options: {\n        timeout\n      }\n    }\n  } = _ref2;\n  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n  // We normalize them to `undefined`\n  exitCode = exitCode === null ? undefined : exitCode;\n  signal = signal === null ? undefined : signal;\n  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n  const errorCode = error && error.code;\n  const prefix = getErrorPrefix({\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const isError = Object.prototype.toString.call(error) === '[object Error]';\n  const shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n  if (isError) {\n    error.originalMessage = error.message;\n    error.message = message;\n  } else {\n    error = new Error(message);\n  }\n  error.shortMessage = shortMessage;\n  error.command = command;\n  error.exitCode = exitCode;\n  error.signal = signal;\n  error.signalDescription = signalDescription;\n  error.stdout = stdout;\n  error.stderr = stderr;\n  if (all !== undefined) {\n    error.all = all;\n  }\n  if ('bufferedData' in error) {\n    delete error.bufferedData;\n  }\n  error.failed = true;\n  error.timedOut = Boolean(timedOut);\n  error.isCanceled = isCanceled;\n  error.killed = killed && !timedOut;\n  return error;\n};\nmodule.exports = makeError;","map":{"version":3,"names":["signalsByName","require","getErrorPrefix","_ref","timedOut","timeout","errorCode","signal","signalDescription","exitCode","isCanceled","undefined","makeError","_ref2","stdout","stderr","all","error","command","killed","parsed","options","description","code","prefix","execaMessage","isError","Object","prototype","toString","call","shortMessage","message","filter","Boolean","join","originalMessage","Error","bufferedData","failed","module","exports"],"sources":["/media/srv/data/diplom/web_sw_test_with_datatables/node_modules/execa/lib/error.js"],"sourcesContent":["'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}